// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import common.ChatIF;import constant.Commands;import model.Command;import ocsf.server.ConnectionToClient;import ocsf.server.ObservableOriginatorServer;import ocsf.server.ObservableServer;import ocsf.server.OriginatorMessage;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Observable;import java.util.Observer;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {  //Class variables *************************************************  /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 5555;  private final ChatIF serverConsole;  private final ObservableOriginatorServer observableServer;  //Constructors ****************************************************  /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port, ChatIF serverConsole) {    observableServer = new ObservableOriginatorServer(port);    observableServer.addObserver(this);    this.serverConsole = serverConsole;  }  //Instance methods ************************************************  /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient(Object msg, ConnectionToClient client) {    String msgString = (String)msg;    if(msgString.startsWith("#")){      handleCommand(new Command(msgString), client);    }    else{      if(client.getInfo("login")==null){        try {          client.sendToClient("Vous ne vous êtes pas login. déconnexion automatique !");          client.close();        } catch (IOException e) {          e.printStackTrace();        }      }      else{        serverConsole.display("Message received: " + msg + " from " + client.getInfo("login"));        observableServer.sendToAllClients(client.getInfo("login") + " : " + msg);      }    }  }  public void handleMessageFromServerUI(Object msg) {    String msgString = (String)msg;    if(msgString.startsWith("#")){      handleServerCommand(new Command(msgString));    }    else{      serverConsole.display("MSG SERVER: " + msg);      observableServer.sendToAllClients("MSG SERVER : " + msg);    }  }  private void handleServerCommand(Command msg) {    switch (msg.getCommand()) {//    #quit - arrête l'exécution du serveur      case Commands.QUIT:        serverConsole.display("closing server");        System.exit(0);//    #stop - termine l'écoute des nouvelles connexions      case Commands.STOP:        observableServer.stopListening();        serverStopped();        break;//    #close - termine l'écoute des nouvelles connexions et déconnecte tous les clients.      case Commands.CLOSE:        try {          observableServer.close();        } catch (IOException e) {          e.printStackTrace();        }        break;//    #setport <port> - appel de la méthode setPort avec les même contraintes que celle de #sethost.      case Commands.SETPORT:        observableServer.setPort(Integer.parseInt(msg.getArgumentList().get(0)));        break;//    #start - lance le serveur en état d'écoute de connexions. La commande est autorisée seulement si le serveur est arrêté      case Commands.START:        try {          observableServer.listen();        } catch (IOException e) {          throw new RuntimeException(e);        }        break;//    #getport      case Commands.GETPORT:        serverConsole.display("port : " + observableServer.getPort());        break;      case Commands.HELP:        serverConsole.display("#quit - arrête l'exécution du serveur\n" +                "#stop - termine l'écoute des nouvelles connexions\n" +                "#close - termine l'écoute des nouvelles connexions et déconnecte tous les clients.\n" +                "#setport <port> - appel de la méthode setPort avec les même contraintes que celle de #sethost.\n" +                "#start - lance le serveur en état d'écoute de connexions. La commande est autorisée seulement si le serveur est arrêté\n" +                "#getport - renvoi le port\n" +                "#help - indique les commandes, leur utilisation et leur utilité");        break;    }  }  public void handleCommand(Command command, ConnectionToClient client){    if(command.getCommand().equals(Commands.LOGIN)){      if (client.getInfo("login")!=null){        try {          client.sendToClient("Erreur: vous êtes déjà login");        } catch (IOException e) {          e.printStackTrace();        }      }else{        client.setInfo("login", command.getArgumentList().get(0));      }    }  }  /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted() {    serverConsole.display("Server listening for connections on port " + observableServer.getPort());  }  /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped() {    serverConsole.display("Server has stopped listening for connections.");  }  //Class methods ***************************************************  @Override  public void update(Observable o, Object arg) {    OriginatorMessage originatorMessage = (OriginatorMessage) arg;    if (ObservableServer.CLIENT_EXCEPTION.equals(originatorMessage.getMessage())) {      clientException(originatorMessage.getOriginator(), new Exception(originatorMessage.getMessage().toString()));    }    else if (ObservableServer.CLIENT_DISCONNECTED.equals(originatorMessage.getMessage())) {      clientDisconnected(originatorMessage.getOriginator());    }    else if (ObservableServer.CLIENT_CONNECTED.equals(originatorMessage.getMessage())) {      clientConnected(originatorMessage.getOriginator());    }    else if (ObservableServer.SERVER_STARTED.equals(originatorMessage.getMessage())) {      serverStarted();    }    else if (ObservableServer.SERVER_STOPPED.equals(originatorMessage.getMessage())) {      serverStopped();    }    else if (ObservableServer.SERVER_CLOSED.equals(originatorMessage.getMessage())) {      serverClosed();    }    else {      handleMessageFromClient(originatorMessage.getMessage(), originatorMessage.getOriginator());    }  }  /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverClosed() {    serverConsole.display("The server has been closed. ");  }  protected void clientConnected(ConnectionToClient client) {    serverConsole.display("A new client has connected: " + client.toString());  }  protected synchronized void clientDisconnected(ConnectionToClient client) {    serverConsole.display("A client has disconnected: " + client.toString());  }  protected synchronized void clientException(ConnectionToClient client, Throwable exception) {    serverConsole.display("A client has crashed: " + client.toString() + " Error message: " + exception.getMessage());  }}//End of EchoServer class