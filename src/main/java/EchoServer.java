// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import common.ChatIF;import constant.Commands;import model.Command;import ocsf.server.AbstractServer;import ocsf.server.ConnectionToClient;import java.io.IOException;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer extends AbstractServer{  //Class variables *************************************************  /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 5555;  private final ChatIF serverConsole;  //Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public  EchoServer(int port, ChatIF serverConsole) {    super(port);    this.serverConsole = serverConsole;  }    //Instance methods ************************************************    /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient(Object msg, ConnectionToClient client) {    String msgString = (String)msg;    if(msgString.startsWith("#")){      handleCommand(new Command(msgString), client);    }    else{      if(client.getInfo("login")==null){        try {          client.sendToClient("Vous ne vous êtes pas login. déconnexion automatique !");          client.close();        } catch (IOException e) {          e.printStackTrace();        }      }      else{        serverConsole.display("Message received: " + msg + " from " + client.getInfo("login"));        this.sendToAllClients(msg);      }    }  }  public void handleMessageFromServerUI(Object msg) {    String msgString = (String)msg;    if(msgString.startsWith("#")){      handleServerCommand(new Command(msgString));    }    else{      serverConsole.display("MSG SERVER: " + msg);      this.sendToAllClients("MSG SERVER: " + msg);    }  }  private void handleServerCommand(Command msg) {    switch (msg.getCommand()) {//    #quit - arrête l'exécution du serveur      case Commands.QUIT:        serverConsole.display("closing server");        System.exit(0);//    #stop - termine l'écoute des nouvelles connexions      case Commands.STOP:        stopListening();        serverStopped();        break;//    #close - termine l'écoute des nouvelles connexions et déconnecte tous les clients.      case Commands.CLOSE:        try {          this.close();        } catch (IOException e) {          e.printStackTrace();        }        break;//    #setport <port> - appel de la méthode setPort avec les même contraintes que celle de #sethost.      case Commands.SETPORT:        setPort(Integer.parseInt(msg.getArgumentList().get(0)));        break;//    #start - lance le serveur en état d'écoute de connexions. La commande est autorisée seulement si le serveur est arrêté      case Commands.START:        try {          listen();        } catch (IOException e) {          e.printStackTrace();        }        break;//    #getport      case Commands.GETPORT:        serverConsole.display("port : " + getPort());        break;    }  }  public void handleCommand(Command command, ConnectionToClient client){    if(command.getCommand().equals(Commands.LOGIN)){      if (client.getInfo("login")!=null){        try {          client.sendToClient("Erreur: vous êtes déjà login");        } catch (IOException e) {          e.printStackTrace();        }      }else{        client.setInfo("login", command.getArgumentList().get(0));      }    }  }  /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted() {    serverConsole.display("Server listening for connections on port " + getPort());  }    /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped() {    serverConsole.display("Server has stopped listening for connections.");  }    //Class methods ***************************************************  @Override  protected void clientConnected(ConnectionToClient client) {    super.clientConnected(client);    serverConsole.display("A new client has connected: " + client.toString());  }  @Override  protected synchronized void clientDisconnected(ConnectionToClient client) {    super.clientDisconnected(client);    serverConsole.display("A client has disconnected: " + client.toString());  }  @Override  protected synchronized void clientException(ConnectionToClient client, Throwable exception) {    super.clientException(client,exception);    serverConsole.display("A client has crashed: " + client.toString() + " Error message: " + exception.getMessage());  }}//End of EchoServer class